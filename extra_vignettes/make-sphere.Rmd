---
title: "Minecraft Spheres"
output: html_notebook
---

Create spheres and domes of any size in Minecraft -- hollow or solid. This is great for building "planets", Death Stars, and floating hemispheres that orbit your minecraft world. You can also use it to build domes over villages or other secluded areas of your world.

![](figure/minecraft-spheres.png)

## Connect to Minecraft server

Connect to your minecraft server.

```{r}
library(miner)
mc_connect("34.210.234.34")
```

## Inputs

Choose radius size and block ID. Also select whether to create a hollow or filled sphere.

```{r}
# Inputs
radius <- 15           # Size of the sphere
blockid <- 20          # Block id (1 = stone; 2 = grass; 20 = glass)
styleid <- 0           # Block style id
fill <- FALSE          # Set to true if you want a solid sphere
offset <- c(0, 0, 0)   # offset from the sphere origin
pos <- getPlayerPos(tail(getPlayerIds(), 1), tile = TRUE) # sphere origin
```

## Create a stack of rings

Create rings using formulae from [Wolfram](http://mathworld.wolfram.com/Sphere.html). This step creates a single hemisphere. Later we will duplicate the hemisphere to create a full sphere.

```{r}
rings <- array(0, c(x = 2 * radius + 1, y = radius + 1, z = 2 * radius + 1))
for(y in 0:radius){
  for(theta in seq(0, 2 * pi, len = 10 * radius)){
    xind <- sqrt(radius ^ 2 - y ^ 2) * cos(theta) + radius
    zind <- sqrt(radius ^ 2 - y ^ 2) * sin(theta) + radius
    rings[round(xind) + 1, y + 1, round(zind) + 1] <- 1
  }
}
```

## Create a solid dome

Use the `fillrow` function to fill in the rings. This creates a solid dome.

```{r}
fillrow <- function(x){
  ind <- which(x == 1)
  if(length(ind) == 0) ind <- 0 
  rng <- range(ind)
  idx <- seq_along(x)
  fill <- idx >= min(rng) & idx <= max(rng)
  fill * 1
}
dome <- aperm(apply(rings, 1:2, fillrow), c(2, 3, 1))
```

## Hollow out the dome

*Optional*. Hollow out the dome. 

```{r}
if(!fill){
  for(y in 1:radius){
    disk <- (dome[, y, ] - dome[, y + 1, ]) == 1
    ring <- rings[, y, ] == 1
    dome[, y, ] <- (disk | ring) * 1
  }
}
```

## Create a sphere

Create a sphere by duplicating the dome.

```{r}
yind <- abs(seq(-radius, radius)) + 1
sphere <- dome[, yind, ,drop = FALSE]
```

## Place blocks to create the sphere

Loop through all the coordinates of the sphere, placing blocks only on those locations that correspond to the sphere. Note: The origin refers to the center of the sphere. You can use `xlim`, `ylim`, and `zlim` to plot a "truncated" sphere. Use `ylim = c(0, radius)` to build a dome.

```{r}
# Define plot dimensions  
xlim <- c(-radius, radius)
ylim <- c(-radius, radius)
zlim <- c(-radius, radius)
xx <- seq(xlim[1], xlim[2]) + radius + 1
yy <- seq(ylim[1], ylim[2]) + radius + 1
zz <- seq(zlim[1], zlim[2]) + radius + 1

# Place blocks to create the sphere
p <- pos + offset - c(radius + 1, radius + 1, radius + 1)
for(x in xx){
  for(y in yy){
    for(z in zz){
      if(sphere[x, y, z] == 1){
        setBlock(p[1] + x, p[2] + y, p[3] + z, blockid, styleid)
      }
    }
  }
}
```

***

## Sphere function

Use the `sphere` function to create a sphere.

```{r}
sphere <- function(
  radius = 15,           # Size of the sphere
  blockid = 20,          # Block id (1 = stone; 2 = grass; 20 = glass)
  styleid = 0,           # Block style id
  fill = FALSE,          # Set to true if you want a solid sphere
  offset = c(0, 0, 0),   # offset from the sphere origin
  pos = getPlayerPos(tail(getPlayerIds(), 1), tile = TRUE), # sphere origin
  xlim, ylim, zlim       # plotting limits for sphere truncation
){

  # Create a stack of rings
  rings <- array(0, c(x = 2 * radius + 1, y = radius + 1, z = 2 * radius + 1))
  for(y in 0:radius){
    for(theta in seq(0, 2 * pi, len = 10 * radius)){
      xind <- sqrt(radius ^ 2 - y ^ 2) * cos(theta) + radius
      zind <- sqrt(radius ^ 2 - y ^ 2) * sin(theta) + radius
      rings[round(xind) + 1, y + 1, round(zind) + 1] <- 1
    }
  }
  
  # Create a solid dome
  fillrow <- function(x){
    ind <- which(x == 1)
    if(length(ind) == 0) ind <- 0 
    rng <- range(ind)
    idx <- seq_along(x)
    fill <- idx >= min(rng) & idx <= max(rng)
    fill * 1
  }
  dome <- aperm(apply(rings, 1:2, fillrow), c(2, 3, 1))
  
  # Hollow out the dome
  if(!fill){
    for(y in 1:radius){
      disk <- (dome[, y, ] - dome[, y + 1, ]) == 1
      ring <- rings[, y, ] == 1
      dome[, y, ] <- (disk | ring) * 1
    }
  }
  
  # Create a sphere
  yind <- abs(seq(-radius, radius)) + 1
  sphere <- dome[, yind, ,drop = FALSE]

  # Define plot dimensions  
  if(missing(xlim)) xlim <- c(-radius, radius)
  if(missing(ylim)) ylim <- c(-radius, radius)
  if(missing(zlim)) zlim <- c(-radius, radius)
  xx <- seq(xlim[1], xlim[2]) + radius + 1
  yy <- seq(ylim[1], ylim[2]) + radius + 1
  zz <- seq(zlim[1], zlim[2]) + radius + 1
  
  # Place blocks to create the sphere
  p <- pos + offset - c(radius + 1, radius + 1, radius + 1)
  for(x in xx){
    for(y in yy){
      for(z in zz){
        if(sphere[x, y, z] == 1){
          setBlock(p[1] + x, p[2] + y, p[3] + z, blockid, styleid)
        }
      }
    }
  }

  # Output current position and sphere origin
  cat("pos:", pos, "\n")
  cat("offset:", offset, "\n")
  cat("sphere origin:", p, "\n")
}
```

## Examples

Consider these examples to create a sphere, dome, floating island, and a Death Star.

```{r}
# Glass sphere
sphere()

# Erase sphere
sphere(blockid = 1, fill = TRUE, radius = 5, offset = c(5,5,5))

# Glass dome
sphere(15, blockid = 20, ylim = c(0, 15))

# Small floating island
sphere(10, blockid = 2, fill = TRUE, offset = c(0, 40, 0), ylim = c(-10, 0))

# Death star
sphere(20, blockid = 1, fill = TRUE, offset = c(0, 25, 35))
sphere(10, blockid = 0, fill = TRUE, offset = c(0, 25, 10))

# Mound
for(i in 0:10) sphere(8, blockid = 2, offset = c(0, i, 0), ylim = c(0, 0))
sphere(8, blockid = 2, offset = c(0, 11, 0), ylim = c(0, 8))

# Gobstopper
for(i in 1:5 * 5) sphere(i, blockid = 95, styleid = i / 5 * 2, offset = c(0, 40, 0))

# Saturn
sphere( 7, 95, 4, TRUE,  c(0, 40, 0))
sphere(15, 95, 1, FALSE, c(0, 40, 0), ylim = c(0, 0))
sphere(17, 95, 8, FALSE, c(0, 40, 0), ylim = c(0, 0))
sphere(21, 95, 9, FALSE, c(0, 40, 0), ylim = c(0, 0))
```


